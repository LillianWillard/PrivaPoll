"use client";

import { useState, useEffect, useCallback } from "react";
import { ethers } from "ethers";
import { useApp } from "@/app/providers";

// Generated by genabi script
import { PrivaPollABI as GeneratedABI } from "@/abi/PrivaPollABI";
import { PrivaPollAddresses as GeneratedAddresses } from "@/abi/PrivaPollAddresses";

// Convert generated addresses to simple Record<number, string>
const PrivaPollAddresses: Record<number, string> = {};
for (const [key, value] of Object.entries(GeneratedAddresses)) {
  const chainId = parseInt(key);
  PrivaPollAddresses[chainId] = value.address;
}

// Use generated ABI
const PrivaPollABI = GeneratedABI.abi;

export interface PollInfo {
  id: bigint;
  creator: string;
  title: string;
  description: string;
  startTime: bigint;
  endTime: bigint;
  questionCount: number;
  isPublic: boolean;
  responseCount: bigint;
  isActive: boolean;
}

export interface QuestionData {
  id: number;
  text: string;
  type: "single" | "multiple";
  options: string[];
}

export interface PollWithQuestions extends PollInfo {
  questions: QuestionData[];
}

export function usePrivaPoll() {
  const { wallet, fhevm } = useApp();
  const [contract, setContract] = useState<ethers.Contract | null>(null);
  const [isReady, setIsReady] = useState(false);

  useEffect(() => {
    if (wallet.signer && wallet.chainId) {
      try {
        const address = PrivaPollAddresses[wallet.chainId];
        if (!address || address === "0x0000000000000000000000000000000000000000") {
          console.warn(`PrivaPoll contract not deployed on chain ${wallet.chainId}`);
          setIsReady(false);
          return;
        }
        const contractInstance = new ethers.Contract(
          address,
          PrivaPollABI,
          wallet.signer
        );
        setContract(contractInstance);
        setIsReady(true);
      } catch (error) {
        console.error("Failed to create contract instance:", error);
        setIsReady(false);
      }
    } else {
      setContract(null);
      setIsReady(false);
    }
  }, [wallet.signer, wallet.chainId]);

  const createPoll = useCallback(
    async (params: {
      title: string;
      description: string;
      startTime: Date;
      endTime: Date;
      questions: QuestionData[];
      isPublic: boolean;
    }) => {
      if (!contract || !fhevm.instance) {
        throw new Error("Contract or FHEVM instance not ready");
      }

      const startTimestamp = Math.floor(params.startTime.getTime() / 1000);
      const endTimestamp = Math.floor(params.endTime.getTime() / 1000);
      const questionsData = JSON.stringify(params.questions);

      const tx = await contract.createPoll(
        params.title,
        params.description,
        startTimestamp,
        endTimestamp,
        questionsData,
        params.questions.length,
        params.isPublic
      );

      const receipt = await tx.wait();

      // Extract pollId from event
      const event = receipt.logs
        .map((log: any) => {
          try {
            return contract.interface.parseLog(log);
          } catch {
            return null;
          }
        })
        .find((e: any) => e && e.name === "PollCreated");

      if (!event) {
        throw new Error("PollCreated event not found");
      }

      return event.args.pollId;
    },
    [contract, fhevm.instance]
  );

  const submitResponse = useCallback(
    async (pollId: bigint, answers: number[]) => {
      if (!contract || !fhevm.instance || !wallet.account) {
        throw new Error("Contract, FHEVM instance, or wallet not ready");
      }

      // Create encrypted input for all answers
      const encryptedInput = fhevm.instance.createEncryptedInput(
        contract.target as string,
        wallet.account
      );

      // Add all answers
      answers.forEach((answer) => {
        encryptedInput.add32(answer);
      });

      const { handles, inputProof } = await encryptedInput.encrypt();

      // Submit response
      const tx = await contract.submitResponse(pollId, handles, inputProof);
      await tx.wait();
    },
    [contract, fhevm.instance, wallet.account]
  );

  const getPollInfo = useCallback(
    async (pollId: bigint): Promise<PollInfo> => {
      if (!contract) {
        throw new Error("Contract not ready");
      }

      const info = await contract.getPollInfo(pollId);
      return {
        id: info.id,
        creator: info.creator,
        title: info.title,
        description: info.description,
        startTime: info.startTime,
        endTime: info.endTime,
        questionCount: Number(info.questionCount),
        isPublic: info.isPublic,
        responseCount: info.responseCount,
        isActive: info.isActive,
      };
    },
    [contract]
  );

  const getPollWithQuestions = useCallback(
    async (pollId: bigint): Promise<PollWithQuestions | null> => {
      if (!contract) {
        throw new Error("Contract not ready");
      }

      // Get poll info
      const info = await getPollInfo(pollId);

      // Query events to get questions data
      const filter = contract.filters.PollCreated(pollId);
      const events = await contract.queryFilter(filter);

      if (events.length === 0) {
        return null;
      }

      const event: any = events[0];
      const questionsData = JSON.parse(event.args.questionsData);

      return {
        ...info,
        questions: questionsData,
      };
    },
    [contract, getPollInfo]
  );

  const getMyPolls = useCallback(async (): Promise<bigint[]> => {
    if (!contract || !wallet.account) {
      return [];
    }

    return await contract.getPollsByCreator(wallet.account);
  }, [contract, wallet.account]);

  const getMyResponses = useCallback(async (): Promise<bigint[]> => {
    if (!contract || !wallet.account) {
      return [];
    }

    return await contract.getResponsesBySender(wallet.account);
  }, [contract, wallet.account]);

  const hasUserResponded = useCallback(
    async (pollId: bigint): Promise<boolean> => {
      if (!contract || !wallet.account) {
        return false;
      }

      return await contract.hasResponded(pollId, wallet.account);
    },
    [contract, wallet.account]
  );

  const closePoll = useCallback(
    async (pollId: bigint) => {
      if (!contract) {
        throw new Error("Contract not ready");
      }

      const tx = await contract.closePoll(pollId);
      await tx.wait();
    },
    [contract]
  );

  const getPollResponses = useCallback(
    async (pollId: bigint): Promise<string[]> => {
      if (!contract) {
        throw new Error("Contract not ready");
      }

      // Query ResponseSubmitted events to get respondent addresses
      const filter = contract.filters.ResponseSubmitted(pollId);
      const events = await contract.queryFilter(filter);

      // Extract unique respondent addresses
      const respondents = events.map((event: any) => event.args.respondent);
      return [...new Set(respondents)]; // Remove duplicates
    },
    [contract]
  );

  const getUserResponses = useCallback(
    async (pollId: bigint, userAddress: string) => {
      if (!contract) {
        throw new Error("Contract not ready");
      }

      return await contract.getUserResponses(pollId, userAddress);
    },
    [contract]
  );

  const decryptResponses = useCallback(
    async (pollId: bigint, userAddress: string): Promise<number[]> => {
      if (!contract || !fhevm.instance || !wallet.account || !wallet.signer) {
        throw new Error("Contract, FHEVM instance, wallet, or signer not ready");
      }

      const encryptedResponses = await getUserResponses(pollId, userAddress);

      if (encryptedResponses.length === 0) {
        return [];
      }

      // Load or create decryption signature
      const { FhevmDecryptionSignature } = await import("@/fhevm/FhevmDecryptionSignature");
      const sig = await FhevmDecryptionSignature.loadOrSign(
        fhevm.instance,
        [contract.target as string],
        wallet.signer,
        `fhevm.decryptionSignature.${wallet.account}`
      );

      if (!sig) {
        throw new Error("Failed to create decryption signature");
      }

      // Prepare handles for batch decryption
      const handles = encryptedResponses.map((handle: any) => ({
        handle: handle,
        contractAddress: contract.target as string,
      }));

      // Batch decrypt all responses
      const results = await fhevm.instance.userDecrypt(
        handles,
        sig.privateKey,
        sig.publicKey,
        sig.signature,
        sig.contractAddresses,
        sig.userAddress,
        sig.startTimestamp,
        sig.durationDays
      );

      // Extract decrypted values
      const decryptedValues: number[] = [];
      for (const handle of encryptedResponses) {
        const value = results[handle];
        decryptedValues.push(value !== undefined ? Number(value) : 0);
      }

      return decryptedValues;
    },
    [contract, fhevm.instance, wallet.account, wallet.signer, getUserResponses]
  );

  return {
    contract,
    isReady: isReady && fhevm.status === "ready",
    createPoll,
    submitResponse,
    getPollInfo,
    getPollWithQuestions,
    getMyPolls,
    getMyResponses,
    hasUserResponded,
    closePoll,
    getPollResponses,
    getUserResponses,
    decryptResponses,
  };
}

